#include<cstdio>
#include<string>
#include<fstream>
#include<stdexcept>
#include<cerrno>
#include<cstdlib>
#include<vector>

#include <sys/types.h>
#include <sys/stat.h>
#include <linux/stat.h>
#include <unistd.h>

#include <DGLCommon/def.h>
#include <DGLCommon/version.h>

void printHelp() {
    printf(DGL_PRODUCT " %s (dgl-android-installer)"
        "\nThe OpenGL(R) debu gger\n\n"
        "Copyright (C) 2013 " DGL_MANUFACTURER ".\n\n "
        "https://github.com/debugler/debugler\\n\n"
        "Usage:"
           "\tdgl-android-installer action\n"
           "\tAvaliable actions:\n"
           "\t\textract:      extracts files to current directory\n"
           "\t\tinstall:      installs " DGL_PRODUCT "\n"
           "\t\tupdate:       updates current installation\n"
           "\t\tuninstall:  uninstalls " DGL_PRODUCT "\n", getVersion().c_str());
}

#define BIN_PATH             "/system/bin/"

#ifdef COMPAT_32
#    define LIB_PATH          "/system/lib64/"
#    define LIB_COMPAT32_PATH "/system/lib/"
#else
#    define LIB_PATH          "/system/lib/"
#endif

//These are generated by objcopy during build process
extern char _binary_dglloader_stripped_start;
extern char _binary_dglloader_stripped_end;
extern char _binary_libdglwrapper_stripped_so_start;
extern char _binary_libdglwrapper_stripped_so_end;

#ifdef COMPAT_32
extern char _binary_dglloader_compat32_stripped_start;
extern char _binary_dglloader_compat32_stripped_end;
extern char _binary_libdglwrapper_compat32_stripped_so_start;
extern char _binary_libdglwrapper_compat32_stripped_so_end;
#endif


const char* app_process = 
    "#!/system/bin/sh\n"
    "exec /system/bin/dglloader "  BIN_PATH "app_process.dgl --egl --nowait --port=unix:/data/local/tmp/dgl-%p-%n -- \"$@\"\n";

struct File {
    const char* name; 
    bool isExecutable;
    bool sysOverwrite;
    const char* begin;
    const char* end;    
};

 File files[] = {
    { "dglloader",        true,  false, &_binary_dglloader_stripped_start,        &_binary_dglloader_stripped_end },
    { "app_process",      true,  true,  app_process,                              app_process + strlen(app_process) + 1 },
    { "libdglwrapper.so", false, false, &_binary_libdglwrapper_stripped_so_start, &_binary_libdglwrapper_stripped_so_end },
};

#ifdef COMPAT_32
const char* app_process32 = 
    "#!/system/bin/sh\n"
    "exec /system/bin/dglloader32 "  BIN_PATH "app_process32.dgl --egl --nowait --port=unix:/data/local/tmp/dgl-%p-%n -- \"$@\"\n";
    
 File compat32Files[] = {
    { "dglloader32",         true,  false, &_binary_dglloader_compat32_stripped_start,        &_binary_dglloader_compat32_stripped_end },
    { "app_process32",       true,  true,  app_process32,                                     app_process32 + strlen(app_process32) + 1 },
    { "libdglwrapper.so",    false, false, &_binary_libdglwrapper_compat32_stripped_so_start, &_binary_libdglwrapper_compat32_stripped_so_end },
};
#endif

bool exists(const std::string& filePath) {
    struct stat S;
    int st = stat(filePath.c_str(), &S);
    if (st == 0) {
        return true;
    }
    if (errno == ENOENT) {
        return false;
    }
    throw std::runtime_error("File " + filePath + ": " + strerror(errno));
}

bool fileIsBinary(const std::string& filePath) {
    std::ifstream fileStr; fileStr.open(filePath, std::ios::binary);
    if (!fileStr.good()) {
        throw std::runtime_error("Cannot read file " + filePath);
    }
    char elfMagic[4];
    char elfMagicRef[sizeof(elfMagic)] = { 0x7F, 'E', 'L', 'F' };
    fileStr.read(elfMagic, sizeof(elfMagic)); 
    for (size_t i = 0; i < sizeof(elfMagic); i++) {
        if (elfMagicRef[i] != elfMagic[i]) {
            return false;
        }
    }
    return true;
}

std::string getRealPathIfSymlink(const std::string& filePath) {
    struct stat st;
    if (lstat(filePath.c_str(), &st) != 0) {
        if (errno == ENOENT) {
            return filePath;
        }
        throw std::runtime_error("File (lstat) " + filePath + ": " + strerror(errno));
    }
    if (!S_ISLNK(st.st_mode)) {
        return filePath; 
    }

    //It is a symlink so return the path it points to.
    std::vector<char> linkname(st.st_size + 1, '\0');
    if (!readlink(filePath.c_str(), &linkname[0], linkname.size())) {
        throw std::runtime_error("File (readlink) " + filePath + ": " + strerror(errno));
    }

    linkname[linkname.size() - 1] = '\0';
    std::string ret = &linkname[0];

    if (ret[0] == '/') {
        //Absolute file path, return
        return ret;
    }
    size_t splitPoint = filePath.find_last_of("/");
    return filePath.substr(0, splitPoint) + "/" + ret;
}

void extractFile(File* file, const char* libPath, const char* binPath, bool overwrite) {
        const std::string path = file->isExecutable?binPath:libPath;
        const std::string filePath = getRealPathIfSymlink(path + "/" + file->name);

        if (exists(filePath)) {
            if (!overwrite) {
                throw std::runtime_error("File " + filePath + " already exists.");
            } else if (file->sysOverwrite && fileIsBinary(filePath)) {
                throw std::runtime_error("Cannot overwrite file " + filePath + ": File is an ELF binary (risk of overwriting original app_process!)");
            }
        }

        printf("Extracting: %s\n", filePath.c_str());

        std::ofstream fileStream; fileStream.open(filePath, std::ios::binary); 
        fileStream.write(file->begin, file->end - file->begin);

        if (!fileStream.good()) {
            throw std::runtime_error("Cannot write file " + filePath);
        }

        fileStream.close();

        mode_t mode; 
        if (file->isExecutable) {
            mode = 0755;
        } else {
            mode = 0644;
        }

        if (chmod(filePath.c_str(), mode)) {
             throw std::runtime_error("Cannot chmod file " + filePath);
        }
}

void backupFile(File* file, const char* libPath) {
    if (file->sysOverwrite) {
            const std::string origPath = getRealPathIfSymlink(std::string(file->isExecutable?BIN_PATH:libPath) + file->name);
            const std::string backupPath = std::string(file->isExecutable?BIN_PATH:libPath) + file->name + ".dgl";
            if (exists(backupPath)) {
                throw std::runtime_error("File " + backupPath + " already exists.");
            }
            printf("Moving: %s > %s\n", origPath.c_str(), backupPath.c_str());
            if (rename(origPath.c_str(), backupPath.c_str())) {
                throw std::runtime_error("Cannot move " + origPath + " to " + backupPath + ": " + strerror(errno));
            }
        }
}

void uninstallFile(File* file, const char* libPath) {
    const std::string filePath = getRealPathIfSymlink(std::string(file->isExecutable?BIN_PATH:libPath) + file->name);
    if (file->sysOverwrite) {
        const std::string backupPath = std::string(file->isExecutable?BIN_PATH:libPath) + file->name + ".dgl";
        printf("Moving: %s > %s\n", backupPath.c_str(), filePath.c_str());
        if (rename(backupPath.c_str(), filePath.c_str())) {
            throw std::runtime_error("Cannot move " + backupPath + " to " + filePath + ": " + strerror(errno));
        }
    } else {
        printf("Removing: %s\n", filePath.c_str());
        if (unlink(filePath.c_str())) {
            throw std::runtime_error("Cannot remove " + filePath  + ": " + strerror(errno));
        }
    }
}

void extract(bool usePath, bool overwrite) {
	const char* binPath = ".";
	const char* libPath = ".";
#ifdef COMPAT_32
	const char* libCompat32Path = ".";
#endif
	if(usePath) {
		binPath = BIN_PATH;
		libPath = LIB_PATH;
#ifdef COMPAT_32
		libCompat32Path = LIB_COMPAT32_PATH;
#endif
	}

    for (size_t i = 0; i < sizeof(files)/sizeof(files[0]); i++) {
        extractFile(&files[i], libPath, binPath, overwrite);
    }
#ifdef COMPAT_32
    for (size_t i = 0; i < sizeof(compat32Files)/sizeof(compat32Files[0]); i++) {
        extractFile(&compat32Files[i], libCompat32Path, binPath, overwrite);
    }
#endif
}

void backupFiles() {
    for (size_t i = 0; i < sizeof(files)/sizeof(files[0]); i++) {
        backupFile(&files[i], LIB_PATH);
    }
#ifdef COMPAT_32
    for (size_t i = 0; i < sizeof(compat32Files)/sizeof(compat32Files[0]); i++) {
        backupFile(&compat32Files[i], LIB_COMPAT32_PATH);
    }
#endif
}

void uninstall() {
    for (size_t i = 0; i < sizeof(files)/sizeof(files[0]); i++) {
        uninstallFile(&files[i], LIB_PATH);
    }
#ifdef COMPAT_32
    for (size_t i = 0; i < sizeof(compat32Files)/sizeof(compat32Files[0]); i++) {
        uninstallFile(&compat32Files[i], LIB_COMPAT32_PATH);
    }
#endif
}

int main(int argc, char** argv) {

    if (argc != 2) {
        printHelp();
        return EXIT_FAILURE;
    }
    
    try {
        if (std::string(argv[1]) == "extract") {
            extract(false, false);
        } else if (std::string(argv[1]) == "install") {
            backupFiles();
            extract(true, false);
        } else if (std::string(argv[1]) == "update") {
            extract(true, true);
        } else if (std::string(argv[1]) == "uninstall") {
            uninstall();
        } else {
            printHelp();
            return EXIT_FAILURE;
        }
    } catch (const std::runtime_error& err) {
        printf("Caught exception: %s\n", err.what());
        return EXIT_FAILURE;
    }

    printf("Success.\n");

    return EXIT_SUCCESS;
}
