#include<cstdio>
#include<string>
#include<fstream>
#include<stdexcept>
#include<cerrno>
#include<cstdlib>

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#include <DGLCommon/def.h>
#include <DGLCommon/version.h>

void printHelp() {
    printf(DGL_PRODUCT " %s (dgl-android-installer)"
        "\nThe OpenGL(R) debu gger\n\n"
        "Copyright (C) 2013 " DGL_MANUFACTURER ".\n\n "
        "https://github.com/debugler/debugler\\n\n"
        "Usage:"
           "\tdgl-android-installer action\n"
           "\tAvaliable actions:\n"
           "\t\textract:      extracts files to current directory\n"
           "\t\tinstall:      installs " DGL_PRODUCT "\n"
           "\t\tupdate:       updates current installation\n"
           "\t\tuninstall:  uninstalls " DGL_PRODUCT "\n", getVersion().c_str());
}

//These are generated by objcopy during build process
extern char _binary_dglloader_start;
extern char _binary_dglloader_end;
extern char _binary_libdglwrapper_so_start;
extern char _binary_libdglwrapper_so_end;


const char* app_process = 
    "#!/system/bin/sh\n"
    "exec /system/bin/dglloader /system/bin/app_process.dgl --egl --nowait --port=unix:/data/local/tmp/dgl-%p -- $*\n";


struct {
    const char* name; 
    bool isExecutable;
    bool sysOverwrite;
    const char* begin;
    const char* end;
} files[] = {
    { "dglloader",        true,  false, &_binary_dglloader_start,        &_binary_dglloader_end },
    { "app_process",      true,  true,  app_process,                     app_process + strlen(app_process) + 1 },
    { "libdglwrapper.so", false, false, &_binary_libdglwrapper_so_start, &_binary_libdglwrapper_so_end },
};


const char* appProcessBackup = "app_process.dgl";


bool exists(const std::string& filePath) {
    struct stat S;
    int st = stat(filePath.c_str(), &S);
    if (st == 0) {
        return true;
    }
    if (errno == ENOENT) {
        return false;
    }
    throw std::runtime_error("File " + filePath + ": " + strerror(errno));
}

bool fileIsBinary(const std::string& filePath) {
    std::ifstream fileStr; fileStr.open(filePath, std::ios::binary);
    if (!fileStr.good()) {
        throw std::runtime_error("Cannot read file " + filePath);
    }
    char elfMagic[4];
    char elfMagicRef[sizeof(elfMagic)] = { 0x7F, 'E', 'L', 'F' };
    fileStr.read(elfMagic, sizeof(elfMagic)); 
    for (size_t i = 0; i < sizeof(elfMagic); i++) {
        if (elfMagicRef[i] != elfMagic[i]) {
            return false;
        }
    }
    return true;
}

void extract(std::string libPath, std::string binPath, bool overwrite = false) {
    
    for (size_t i = 0; i < sizeof(files)/sizeof(files[0]); i++) {

        const std::string filePath = (files[i].isExecutable?binPath:libPath) + "/" + files[i].name;

        if (exists(filePath)) {
            if (!overwrite) {
                throw std::runtime_error("File " + filePath + " already exists.");
            } else if (files[i].sysOverwrite && fileIsBinary(filePath)) {
                throw std::runtime_error("Cannot overwrite file " + filePath + ": File is an ELF binary (risk of overwriting original app_process!)");
            }
        }

        printf("Extracting: %s\n", filePath.c_str());

        std::ofstream fileStream; fileStream.open(filePath, std::ios::binary); 
        fileStream.write(files[i].begin, files[i].end - files[i].begin);

        if (!fileStream.good()) {
            throw std::runtime_error("Cannot write file " + filePath);
        }

        fileStream.close();

        mode_t mode; 
        if (files[i].isExecutable) {
            mode = 0755;
        } else {
            mode = 0644;
        }

        if (chmod(filePath.c_str(), mode)) {
             throw std::runtime_error("Cannot chmod file " + filePath);
        }
    }
}

void filesBackup() {
    for (size_t i = 0; i < sizeof(files)/sizeof(files[0]); i++) {
        if (files[i].sysOverwrite) {
            const std::string origPath = std::string(files[i].isExecutable?"/system/bin/":"/system/lib/") + files[i].name;
            const std::string backupPath = origPath + ".dgl";
            if (exists(backupPath)) {
                throw std::runtime_error("File " + backupPath + " already exists.");
            }
            printf("Moving: %s > %s\n", origPath.c_str(), backupPath.c_str());
            if (rename(origPath.c_str(), backupPath.c_str())) {
                throw std::runtime_error("Cannot move " + origPath + " to " + backupPath + ": " + strerror(errno));
            }
        }
    }
}

void uninstall() {

    for (size_t i = 0; i < sizeof(files)/sizeof(files[0]); i++) {
        const std::string filePath = std::string(files[i].isExecutable?"/system/bin/":"/system/lib/") + files[i].name;
        if (files[i].sysOverwrite) {
            const std::string backupPath = filePath + ".dgl";
            printf("Moving: %s > %s\n", backupPath.c_str(), filePath.c_str());
            if (rename(backupPath.c_str(), filePath.c_str())) {
                throw std::runtime_error("Cannot move " + backupPath + " to " + filePath + ": " + strerror(errno));
            }
        } else {
            printf("Removing: %s\n", filePath.c_str());
            if (unlink(filePath.c_str())) {
                throw std::runtime_error("Cannot remove " + filePath  + ": " + strerror(errno));
            }
        }
    }
}

int main(int argc, char** argv) {

    if (argc != 2) {
        printHelp();
        return EXIT_FAILURE;
    }
    
    try {
        if (std::string(argv[1]) == "extract") {
            extract(".", ".");
        } else if (std::string(argv[1]) == "install") {
            filesBackup();
            extract("/system/lib", "/system/bin");
        } else if (std::string(argv[1]) == "update") {
            extract("/system/lib", "/system/bin", true);
        } else if (std::string(argv[1]) == "uninstall") {
            uninstall();
        } else {
            printHelp();
            return EXIT_FAILURE;
        }
    } catch (const std::runtime_error& err) {
        printf("Caught exception: %s\n", err.what());
        return EXIT_FAILURE;
    }

    printf("Success.\n");

    return EXIT_SUCCESS;
}